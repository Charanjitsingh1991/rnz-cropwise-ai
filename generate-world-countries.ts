// generate-world-countries.ts
// Run:  npx ts-node generate-world-countries.ts
//       (or) npm i -D ts-node typescript && npx ts-node generate-world-countries.ts

import { writeFileSync } from "fs";
import https from "https";

export interface Country {
  code: string;
  name: string;
  states?: State[];
  regions: string[];
  coordinates: { latitude: number; longitude: number };
  currency: string;
  timezone: string[];
}
export interface State {
  code: string;
  name: string;
  districts?: string[];
  coordinates: { latitude: number; longitude: number };
}

type RestCountry = {
  cca2?: string;
  name?: { common?: string };
  latlng?: [number, number];
  timezones?: string[];
  currencies?: Record<string, { name?: string; symbol?: string }>;
  region?: string;
  subregion?: string;
};

function getJSON<T = any>(url: string): Promise<T> {
  return new Promise((resolve, reject) => {
    https
      .get(url, (res) => {
        let data = "";
        res.on("data", (chunk) => (data += chunk));
        res.on("end", () => {
          try {
            resolve(JSON.parse(data));
          } catch (e) {
            reject(e);
          }
        });
      })
      .on("error", reject);
  });
}

function pickCurrencyCode(currencies?: RestCountry["currencies"]): string {
  if (!currencies) return "";
  const codes = Object.keys(currencies);
  return codes[0] ?? "";
}

function toCountry(rc: RestCountry): Country | null {
  const code = (rc.cca2 || "").toUpperCase();
  const name = rc.name?.common || "";
  if (!code || !name) return null;

  const [lat, lng] = rc.latlng ?? [0, 0];

  const regions = [
    ...(rc.region ? [rc.region] : []),
    ...(rc.subregion ? [rc.subregion] : []),
  ];

  return {
    code,
    name,
    states: [], // enrich later if you want subdivisions
    regions,
    coordinates: { latitude: lat, longitude: lng },
    currency: pickCurrencyCode(rc.currencies),
    timezone: rc.timezones ?? [],
  };
}

async function main() {
  const url =
    "https://restcountries.com/v3.1/all?fields=cca2,name,latlng,timezones,currencies,region,subregion";

  const data = await getJSON<RestCountry[]>(url);

  const mapped: Country[] = data
    .map(toCountry)
    .filter((c): c is Country => Boolean(c))
    .sort((a, b) => a.name.localeCompare(b.name));

  const header = `// Generated by generate-world-countries.ts
// Shape matches your Country & State interfaces.
// Notes:
// - "states" is empty by default (safe for lazy enrichment).
// - "regions" includes UN region and subregion.
// - "currency" is the first ISO-4217 reported (some countries have multiple).
// - "coordinates" is national lat/lng centroid.
// - "timezone" lists IANA TZ IDs.

export interface Country {
  code: string;
  name: string;
  states?: State[];
  regions: string[];
  coordinates: {
    latitude: number;
    longitude: number;
  };
  currency: string;
  timezone: string[];
}

export interface State {
  code: string;
  name: string;
  districts?: string[];
  coordinates: {
    latitude: number;
    longitude: number;
  };
}

export const worldCountries: Country[] = `;

  const body = JSON.stringify(mapped, null, 2);
  const footer = `
  as const;

export const getCountryByCode = (code: string): Country | undefined =>
  worldCountries.find(c => c.code === code);

export const getStatesByCountryCode = (countryCode: string) =>
  getCountryByCode(countryCode)?.states ?? [];

export const searchCountries = (searchTerm: string): Country[] =>
  worldCountries.filter(c =>
    c.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    c.code.toLowerCase().includes(searchTerm.toLowerCase())
  );
`;

  writeFileSync("worldCountries.ts", header + body + footer, "utf-8");
  console.log("âœ… Wrote worldCountries.ts with", mapped.length, "countries.");
}

main().catch((e) => {
  console.error("Generation failed:", e);
  process.exit(1);
});
